/*
 * This library is built for the extract.pyx file. While you can use this library
 * directly, it is strongly recommended you use the Cython version.
 *
 * Example C usage:
 *
 *      #include "_extract.c"
 *      video_stream* vs = (video_stream*) malloc(sizeof(video_stream));
 *      if (extract_video("file.mpg", vs) != 0) {
 *          printf("error reading video file");
 *      }
 *      unsigned char *buffer;
 *      while (read_frame(vs, &buffer) == 0) {
 *          dosomething(&buffer, vs.width, vs.height);
 *      }
 *      cleanup_extraction(vs);
 *
 * Example Python usage:
 *
 *      import ffmpeg
 *      for frame in ffmpeg.extract("file.jpg"):
 *          dosomething(frame)
 */

extern "C"
{
#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libswscale/swscale.h>  
}

#include "_extract.h"

/**
 * Starts the extraction process of a video using ffmpeg.
 *
 * - filename must be a c-style string of the location of the
 * videofile. It is relative to the current working directory.
 * - video_stream must be a pointer to a video_stream memory
 * location. You must allocate this using malloc prior.
 *
 * Returns 0 on success, nonzero otherwise.
 */
int extract_video(char *filename, struct video_stream *output)
{
    AVFormatContext* format_context;
    AVCodecContext* codec_context;  
    AVCodec* codec;                 
    AVFrame* frame_reg;             
    AVFrame* frame_rgb;             
    uint8_t* buffer;                
    int video_stream = -1;
    int num_bytes;                  
    unsigned int i;

    av_register_all();

    if (av_open_input_file(&format_context, filename, 0, 0, 0) != 0)
    {
        return 1;
    }
    if (av_find_stream_info(format_context) < 0)
    {
        return 1;
    }

    // determine video stream
    for (i = 0; i < format_context->nb_streams; i++)
    {
        if (format_context->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
        {
            video_stream = i;
            break;
        }
    }
    if (video_stream == -1)
    {
        return 2;
    }
    // video stream exists in video_stream

    codec_context = format_context->streams[video_stream]->codec;
    codec = avcodec_find_decoder(codec_context->codec_id);
    if (codec == 0)
    {
        return 3;
    }

    if (avcodec_open(codec_context, codec) < 0)
    {
        return 4;
    }

    // hack to correct wrong frame rates generated by codecs
    if (codec_context->time_base.num > 1000 && codec_context->time_base.den == 1)
    {
        codec_context->time_base.den = 1000;
    }

    frame_reg = avcodec_alloc_frame();
    frame_rgb = avcodec_alloc_frame();
    if (frame_rgb == 0)
    {
        return 5;
    }

    num_bytes = avpicture_get_size(PIX_FMT_RGB24, codec_context->width, codec_context->height);

    buffer = (uint8_t*) malloc(num_bytes);

    avpicture_fill((AVPicture*) frame_rgb, buffer, PIX_FMT_RGB24, codec_context->width, codec_context->height);

    output->format_context = (void*) format_context;
    output->codec_context = (void*) codec_context;
    output->frame_reg = (void*) frame_reg;
    output->frame_rgb = (void*) frame_rgb;
    output->buffer = buffer;
    output->video_stream = video_stream;
    output->width = codec_context->width;
    output->height = codec_context->height;
    
    return 0;
}

/**
 * Reads the next frame from the video stream and assigns the output
 * to output.
 *
 * - stream must be the vidoe stream that was initialized in
 * extract_video above.
 * - output a pointer to a buffer where the frame will be written to.
 *
 * Returns 0 on success, -1 on end of stream.
 */
int read_frame(struct video_stream *stream, unsigned char **output)
{
    AVFormatContext *format_context = (AVFormatContext*) stream->format_context;
    AVCodecContext *codec_context = (AVCodecContext*) stream->codec_context;
    AVFrame *frame_reg = (AVFrame*) stream->frame_reg;
    AVFrame *frame_rgb = (AVFrame*) stream->frame_rgb;
    int video_stream = stream->video_stream;
    AVPacket packet;
    int frame_finished;
    int w, h;

    while (av_read_frame(format_context, &packet) >= 0)
    {
        if (packet.stream_index == video_stream)
        {
            //avcodec_decode_video(codec_context, frame_reg, &frame_finished, packet.data, packet.size);

        AVPacket avpkt; 
	av_init_packet(&avpkt); 
	avpkt.data = packet.data; 
	avpkt.size = packet.size; 
 	avpkt.flags = AV_PKT_FLAG_KEY; 
 	avcodec_decode_video2(codec_context, 
 	frame_reg, &frame_finished, &avpkt); 

            if (frame_finished)
            {
                static struct SwsContext *img_convert_ctx;
                if (img_convert_ctx == 0)
                {
                    w = codec_context->width;
                    h = codec_context->height;

                    img_convert_ctx = sws_getContext(w, h, codec_context->pix_fmt, w, h, PIX_FMT_RGB24, SWS_BICUBIC, 0, 0, 0);
                }

                sws_scale(img_convert_ctx, frame_reg->data, frame_reg->linesize, 0, codec_context->height, frame_rgb->data, frame_rgb->linesize);
                av_free_packet(&packet);

                *output = frame_rgb->data[0];

                return 0;
            }
        }
    }

    return -1;
}

/**
 * Frees memory allocated by extract_video and read_frame.
 *
 * - stream is a pointer to the video stream created in extract_video.
 * After calling, this pointer will be invalid.
 *
 * You must call this method after you are done, or you will leak memory!
 */
void cleanup_extraction(struct video_stream *stream)
{
    free((uint8_t*) stream->buffer);
    av_free((AVFrame*) stream->frame_rgb);
    av_free((AVFrame*) stream->frame_reg);
    avcodec_close((AVCodecContext*) stream->codec_context);
    av_close_input_file((AVFormatContext*) stream->format_context);
}
